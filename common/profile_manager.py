import os
from openpilot.common.params import Params
# cereal.user_profile_pb2 will be generated by the build system from user_profile.proto
from cereal.user_profile_pb2 import UserProfile, ProfileSettings, UserProfilesCollection, DrivingModelParameters

PROFILES_FILE = "/data/user_profiles.bin" # Changed to .bin for protobuf
CURRENT_PROFILE_PARAM = "CurrentProfileName"
DEFAULT_PROFILE_NAME = "Default"

# Mapping from ProfileSettings field names to Param keys if they differ,
# or to note their type for params.get/put conversion.
# For bools, "1" or "0". For ints, string representation.
# This helps in _get_current_op_settings_proto and load_profile.
PARAM_MAP = {
    "openpilot_enabled_toggle": ("OpenpilotEnabledToggle", "bool"),
    "experimental_mode": ("ExperimentalMode", "bool"),
    "disengage_on_accelerator": ("DisengageOnAccelerator", "bool"),
    "longitudinal_personality": ("LongitudinalPersonality", "int"),
    "is_ldw_enabled": ("IsLdwEnabled", "bool"),
    "always_on_dm": ("AlwaysOnDM", "bool"),
    "record_front": ("RecordFront", "bool"),
    "is_metric": ("IsMetric", "bool"),
    "record_audio": ("RecordAudio", "bool"),
    "driving_model_name": ("DrivingModel", "str"),
    "auto_lane_change_enabled": ("AutoLaneChangeEnabled", "bool"),
    "lane_change_aggressiveness": ("LaneChangeAggressiveness", "int"),
    # "system_volume": ("SystemVolume", "int"), # Deferred
}


def _read_profiles_collection():
    """Reads the UserProfilesCollection from the binary file."""
    collection = UserProfilesCollection()
    if not os.path.exists(PROFILES_FILE):
        return collection  # Return empty collection
    try:
        with open(PROFILES_FILE, "rb") as f:
            collection.ParseFromString(f.read())
    except Exception as e: # Broad exception for file read or parse errors
        print(f"Error reading or parsing profiles file {PROFILES_FILE}: {e}")
        # Return an empty collection to allow recreating/overwriting if corrupted
        return UserProfilesCollection()
    return collection

def _write_profiles_collection(collection: UserProfilesCollection):
    """Writes the UserProfilesCollection to the binary file."""
    try:
        with open(PROFILES_FILE, "wb") as f:
            f.write(collection.SerializeToString())
    except OSError as e:
        print(f"Error writing profiles file {PROFILES_FILE}: {e}")
        return False
    return True

def get_all_profiles_collection():
    """Returns the entire UserProfilesCollection object."""
    return _read_profiles_collection()

def get_profiles_names():
    """Returns a list of all profile names."""
    collection = _read_profiles_collection()
    return [p.profile_name for p in collection.profiles]

def get_profile_settings(name: str) -> ProfileSettings | None:
    """
    Returns the ProfileSettings protobuf object for a given profile name.
    Returns None if the profile doesn't exist.
    """
    collection = _read_profiles_collection()
    for profile in collection.profiles:
        if profile.profile_name == name:
            return profile.settings
    return None

def get_user_profile(name: str) -> UserProfile | None:
    """
    Returns the UserProfile protobuf object for a given profile name.
    Returns None if the profile doesn't exist.
    """
    collection = _read_profiles_collection()
    for profile in collection.profiles:
        if profile.profile_name == name:
            return profile
    return None

def _get_current_op_settings_proto() -> ProfileSettings:
    """Gets current values of supported settings from Params and returns a ProfileSettings proto."""
    params = Params()
    settings_proto = ProfileSettings()
    settings_proto.version = 1 # Example version

    for proto_field_name, (param_key, param_type) in PARAM_MAP.items():
        val_str = params.get(param_key, encoding='utf-8')
        if val_str is not None:
            try:
                if param_type == "bool":
                    setattr(settings_proto, proto_field_name, val_str == "1")
                elif param_type == "int":
                    setattr(settings_proto, proto_field_name, int(val_str))
                elif param_type == "str":
                    setattr(settings_proto, proto_field_name, val_str)
                # Add other types like float if needed
            except (ValueError, TypeError) as e:
                print(f"Warning: Could not convert param {param_key} (value: '{val_str}') to {param_type}: {e}")
        # If param is not set, the optional field in proto remains unset.
        # Default values from proto definition will apply if not explicitly set.
    return settings_proto


def create_profile_from_current_settings(name: str) -> bool:
    """
    Creates a new profile with the given name, populated from current OpenPilot settings.
    Returns True on success, False on failure (e.g., profile name exists).
    """
    collection = _read_profiles_collection()
    if any(p.profile_name == name for p in collection.profiles):
        print(f"Error: Profile '{name}' already exists.")
        return False

    new_profile = collection.profiles.add()
    new_profile.version = 1 # Example version
    new_profile.profile_name = name
    new_profile.settings.CopyFrom(_get_current_op_settings_proto())
    # new_profile.model_specific_params can be set here if needed

    return _write_profiles_collection(collection)

def save_profile_settings(name: str, profile_settings_proto: ProfileSettings,
                          model_params_proto: DrivingModelParameters | None = None) -> bool:
    """
    Creates or updates a profile.
    If model_params_proto is provided, it's also updated.
    """
    collection = _read_profiles_collection()
    profile_to_update = None
    for p in collection.profiles:
        if p.profile_name == name:
            profile_to_update = p
            break

    if profile_to_update is None: # New profile
        profile_to_update = collection.profiles.add()
        profile_to_update.profile_name = name
        profile_to_update.version = 1

    profile_to_update.settings.CopyFrom(profile_settings_proto)
    if model_params_proto:
        profile_to_update.model_specific_params.CopyFrom(model_params_proto)
    elif profile_to_update.HasField("model_specific_params"): # Clear if not provided
        profile_to_update.ClearField("model_specific_params")

    return _write_profiles_collection(collection)


def delete_profile(name: str) -> bool:
    """Deletes a profile. Returns True on success, False if profile not found."""
    collection = _read_profiles_collection()

    profile_to_delete_idx = -1
    for i, p in enumerate(collection.profiles):
        if p.profile_name == name:
            profile_to_delete_idx = i
            break

    if profile_to_delete_idx == -1:
        print(f"Error: Profile '{name}' not found for deletion.")
        return False

    del collection.profiles[profile_to_delete_idx]

    # If the deleted profile was the current one, manager should handle setting a new current one (e.g. Default)
    # This logic is typically in ensure_default_profile or called after delete by UI
    return _write_profiles_collection(collection)


    params = Params()
    name = params.get(CURRENT_PROFILE_PARAM, encoding='utf-8')
    return name if name else DEFAULT_PROFILE_NAME

def set_current_profile_name(name: str) -> bool:
    """Writes CurrentProfileName to params. Ensures profile exists."""
    params = Params()
    # Ensure the profile exists before setting it as current
    # This check is important to prevent pointing to a non-existent profile.
    if name == DEFAULT_PROFILE_NAME or any(p.profile_name == name for p in _read_profiles_collection().profiles):
        params.put(CURRENT_PROFILE_PARAM, name)
        return True
    print(f"Warning: Attempted to set current profile to non-existent name '{name}'.")
    return False

def load_profile(name: str) -> bool:
    """
    Loads the profile's settings from its ProfileSettings protobuf and applies them to Params.
    Sets the loaded profile as the current profile.
    Returns True on success, False if profile not found or error during loading.
    """
    profile_settings_proto = get_profile_settings(name)

    if profile_settings_proto is None:
        if name == DEFAULT_PROFILE_NAME: # Special case for default
            print(f"Loading default settings (as '{name}' profile not found in collection).")
            # Apply hardcoded defaults or ensure params are at their compiled defaults.
            # For now, this means only setting CurrentProfileName.
            # A more robust default load would iterate through PARAM_MAP and set known defaults.
            params = Params()
            # Example: params.put("ExperimentalMode", "0")
            # This part needs careful definition of what "Default" means in terms of actual param values.
            # For now, we assume the ensure_default_profile created one with some values.
            set_current_profile_name(DEFAULT_PROFILE_NAME)
            # We might want to actually apply the default settings from the default profile proto here
            # if it exists. Let's refine this:
            default_proto_settings = get_profile_settings(DEFAULT_PROFILE_NAME)
            if default_proto_settings is not None:
                profile_settings_proto = default_proto_settings
                print(f"Applying settings from '{DEFAULT_PROFILE_NAME}' profile proto.")
            else: # Should not happen if ensure_default_profile ran
                print(f"CRITICAL: '{DEFAULT_PROFILE_NAME}' profile proto not found even after trying to load it.")
                return False # Cannot load default if its definition is missing
        else:
            print(f"Error: Profile '{name}' not found in collection.")
            return False

    params = Params()
    success = True
    print(f"Applying settings from profile: {name}")

    for field_descriptor in profile_settings_proto.DESCRIPTOR.fields:
        proto_field_name = field_descriptor.name
        if profile_settings_proto.HasField(proto_field_name): # Check if optional field is set
            value = getattr(profile_settings_proto, proto_field_name)

            if proto_field_name in PARAM_MAP:
                param_key, param_type = PARAM_MAP[proto_field_name]
                param_value_str = ""
                try:
                    if param_type == "bool":
                        param_value_str = "1" if value else "0"
                    elif param_type == "int":
                        param_value_str = str(value)
                    elif param_type == "str":
                        param_value_str = value
                    else:
                        print(f"Warning: Unknown param_type '{param_type}' for proto field '{proto_field_name}'.")
                        continue

                    params.put(param_key, param_value_str)
                    # print(f"  Set param '{param_key}' to '{param_value_str}' (from proto field '{proto_field_name}')")
                except Exception as e:
                    print(f"Error setting param {param_key} for profile {name}: {e}")
                    success = False
            # else:
                # print(f"  Skipping proto field '{proto_field_name}': not found in PARAM_MAP.")

    if success:
        set_current_profile_name(name)
        print(f"Successfully loaded and applied profile: {name}")
        # TODO: Consider if a system event/reboot/process restart is needed for some settings.
    else:
        print(f"Failed to fully load or apply profile: {name}")

    return success

def ensure_default_profile():
    """
    Ensures that a 'Default' profile exists in the UserProfilesCollection.
    If not, it creates one with predefined default settings.
    Also ensures CurrentProfileName param is set and valid.
    """
    params = Params()
    collection = _read_profiles_collection()

    current_profile_param_value = params.get(CURRENT_PROFILE_PARAM, encoding='utf-8')
    found_default_profile = any(p.profile_name == DEFAULT_PROFILE_NAME for p in collection.profiles)

    if not found_default_profile:
        print(f"'{DEFAULT_PROFILE_NAME}' profile not found in collection, creating one...")
        default_profile = collection.profiles.add()
        default_profile.profile_name = DEFAULT_PROFILE_NAME
        default_profile.version = 1

        # Populate ProfileSettings with some sensible defaults
        ds = default_profile.settings
        ds.version = 1
        ds.openpilot_enabled_toggle = True
        ds.experimental_mode = False
        ds.disengage_on_accelerator = True
        ds.longitudinal_personality = 1  # Standard
        ds.is_ldw_enabled = True
        ds.always_on_dm = False
        ds.record_front = False # Default to not recording driver camera for privacy
        ds.is_metric = False # Default to imperial
        ds.record_audio = False
        ds.driving_model_name = "default" # A generic default model name
        ds.auto_lane_change_enabled = True
        ds.lane_change_aggressiveness = 2 # Normal

        if not _write_profiles_collection(collection):
            print(f"CRITICAL: Failed to write updated collection with new '{DEFAULT_PROFILE_NAME}' profile.")
            return # Avoid further issues if write fails
        print(f"'{DEFAULT_PROFILE_NAME}' profile created and saved.")
        found_default_profile = True # It exists now

    # Check if CurrentProfileName param points to a valid profile
    current_profile_name_is_valid = False
    if current_profile_param_value:
        if any(p.profile_name == current_profile_param_value for p in collection.profiles):
            current_profile_name_is_valid = True
        elif current_profile_param_value == DEFAULT_PROFILE_NAME and found_default_profile: # Param might be "Default" but proto just created
             current_profile_name_is_valid = True


    if not current_profile_name_is_valid:
        new_current_name = DEFAULT_PROFILE_NAME
        print(f"CurrentProfileName ('{current_profile_param_value}') is invalid or not set. Setting to '{new_current_name}'.")
        params.put(CURRENT_PROFILE_PARAM, new_current_name)
        # No need to call load_profile here, that's for the startup sequence to decide.
        # This function just ensures the param *points* to a valid profile name.

    # Sanity check: current_profile_name param should now be valid
    # final_current_name = params.get(CURRENT_PROFILE_PARAM, encoding='utf-8')
    # print(f"ensure_default_profile: Final CurrentProfileName param is '{final_current_name}'")


if __name__ == '__main__':
    params = Params() # For direct param interaction in test

    print("Profile Manager (Protobuf) Test")
    print("PARAM_MAP:", PARAM_MAP)
    print("-" * 30)

    # 1. Ensure default profile exists and CurrentProfileName is set
    ensure_default_profile()
    print(f"Initial current profile from param: {get_current_profile_name()}")
    print(f"All profile names in .bin: {get_profiles_names()}")
    default_settings = get_profile_settings(DEFAULT_PROFILE_NAME)
    if default_settings:
        print(f"Default profile settings: Experimental={default_settings.experimental_mode}, Model='{default_settings.driving_model_name}'")
    print("-" * 30)

    # 2. Create a new profile from current OP settings
    test_profile_name = "TestProtoProfile1"
    if test_profile_name not in get_profiles_names():
        print(f"Creating '{test_profile_name}' from current OP params...")
        # Let's set some params first to see them captured
        params.put("ExperimentalMode", "1")
        params.put("DrivingModel", "custom_op_model")
        if create_profile_from_current_settings(test_profile_name):
            print(f"'{test_profile_name}' created.")
        else:
            print(f"Failed to create '{test_profile_name}'. It might already exist if test run before.")
    else:
        print(f"'{test_profile_name}' already exists.")

    retrieved_test_settings = get_profile_settings(test_profile_name)
    if retrieved_test_settings:
        print(f"'{test_profile_name}' settings: ExpMode={retrieved_test_settings.experimental_mode}, Model='{retrieved_test_settings.driving_model_name}'")
    print(f"All profiles: {get_profiles_names()}")
    print("-" * 30)

    # 3. Modify and save a profile (e.g., the one just created or a new one)
    custom_profile_name = "CustomProtoSport"
    sport_settings = ProfileSettings()
    sport_settings.version = 1
    sport_settings.experimental_mode = True
    sport_settings.longitudinal_personality = 0 # Aggressive
    sport_settings.driving_model_name = "SuperSportModel_v2"
    sport_settings.auto_lane_change_enabled = True
    sport_settings.lane_change_aggressiveness = 3

    # Example of setting model specific params (though DrivingModelParameters is basic)
    sport_model_params = DrivingModelParameters()
    sport_model_params.version = 1
    sport_model_params.float_params["custom_steer_factor"] = 1.25

    print(f"Saving settings for '{custom_profile_name}'...")
    save_profile_settings(custom_profile_name, sport_settings, sport_model_params)

    retrieved_custom_settings = get_profile_settings(custom_profile_name)
    retrieved_custom_model_params = get_user_profile(custom_profile_name).model_specific_params
    if retrieved_custom_settings:
        print(f"'{custom_profile_name}' settings: ExpMode={retrieved_custom_settings.experimental_mode}, Pers={retrieved_custom_settings.longitudinal_personality}")
        if retrieved_custom_model_params.HasField("version"): # Check if set
             print(f"'{custom_profile_name}' model params: custom_steer_factor={retrieved_custom_model_params.float_params.get('custom_steer_factor')}")

    print(f"All profiles: {get_profiles_names()}")
    print("-" * 30)

    # 4. Load a profile and check if params are set
    print(f"Loading profile '{custom_profile_name}'...")
    if load_profile(custom_profile_name):
        print(f"Successfully loaded '{custom_profile_name}'. Current profile param: {get_current_profile_name()}")
        print(f"  Param ExperimentalMode (should be 1): {params.get('ExperimentalMode', encoding='utf-8')}")
        print(f"  Param LongitudinalPersonality (should be 0): {params.get('LongitudinalPersonality', encoding='utf-8')}")
        print(f"  Param DrivingModel (should be SuperSportModel_v2): {params.get('DrivingModel', encoding='utf-8')}")
    else:
        print(f"Failed to load '{custom_profile_name}'.")
    print("-" * 30)

    # 5. Load Default profile and check params
    # First, let's change a param to see if loading Default reverts it (based on Default's stored settings)
    params.put("ExperimentalMode", "1")
    print(f"Manually set ExperimentalMode to: {params.get('ExperimentalMode', encoding='utf-8')}")

    print(f"Loading profile '{DEFAULT_PROFILE_NAME}'...")
    if load_profile(DEFAULT_PROFILE_NAME):
        print(f"Successfully loaded '{DEFAULT_PROFILE_NAME}'. Current profile param: {get_current_profile_name()}")
        default_settings_check = get_profile_settings(DEFAULT_PROFILE_NAME)
        expected_exp_mode_default = "1" if default_settings_check and default_settings_check.experimental_mode else "0"
        print(f"  Param ExperimentalMode (should be {expected_exp_mode_default} based on Default profile): {params.get('ExperimentalMode', encoding='utf-8')}")
    else:
        print(f"Failed to load '{DEFAULT_PROFILE_NAME}'.")
    print("-" * 30)

    # 6. Delete a profile
    profile_to_delete = test_profile_name
    print(f"Deleting '{profile_to_delete}'...")
    if delete_profile(profile_to_delete):
        print(f"Successfully deleted '{profile_to_delete}'.")
    else:
        print(f"Failed to delete '{profile_to_delete}' (may not exist).")
    print(f"All profiles after delete: {get_profiles_names()}")

    # Ensure current profile is still valid after potential deletion of current
    current_after_delete = get_current_profile_name()
    if current_after_delete == profile_to_delete : # If we deleted the current one
        print(f"Current profile was '{profile_to_delete}', which was deleted. Re-validating...")
        ensure_default_profile() # Should reset to Default if current was deleted
        print(f"New current profile after ensuring default: {get_current_profile_name()}")
        load_profile(get_current_profile_name()) # Load the new current one
    print("-" * 30)

    print("Profile manager (protobuf) test finished.")


def on_first_boot_or_update():
    """
    Call this function during the system's first boot or after an update
    to ensure profile system is correctly initialized.
    This involves ensuring a default profile exists and loading the active profile.
    """
    print("Profile manager: on_first_boot_or_update sequence started.")
    ensure_default_profile() # Ensures Default profile exists and CurrentProfileName param is valid

    current_profile_name_from_param = get_current_profile_name()
    print(f"Attempting to load active profile '{current_profile_name_from_param}' on startup...")

    if not load_profile(current_profile_name_from_param):
        print(f"Failed to load profile '{current_profile_name_from_param}' specified in params.")
        print(f"Attempting to load '{DEFAULT_PROFILE_NAME}' profile instead...")
        if load_profile(DEFAULT_PROFILE_NAME):
            print(f"Successfully loaded '{DEFAULT_PROFILE_NAME}' profile on fallback.")
        else:
            # This is a critical state: couldn't load Default profile.
            # System might be in an inconsistent state regarding params.
            print(f"CRITICAL: Failed to load '{DEFAULT_PROFILE_NAME}' profile on fallback. System params may not match any profile.")
    else:
        print(f"Successfully loaded active profile '{current_profile_name_from_param}' on startup.")
    print("Profile manager: on_first_boot_or_update sequence finished.")

# Example of how it might be called by the system startup (e.g., from manager.py)
# This should not run automatically when module is imported, but explicitly called.
# if __name__ == "common.profile_manager": # This check is not reliable for explicit call
#    on_first_boot_or_update()
